package models

import (
	"fmt"
	"time"
)

// State of a task
type State string

const (
	// Unknown means task state is not defined
	Unknown State = "UNKNOWN"
	// Queued means task was submitted and waiting
	Queued State = "QUEUED"
	// Initializing means required files are be gathering before execution
	// for example, downloading Docker image
	Initializing State = "INITIALIZING"
	// Running means tasks is been executed by some worker node
	Running State = "RUNNING"
	// Paused is not used
	Paused State = "PAUSED"
	// Complete means task was terminated successfully, aka 0 return code
	Complete State = "COMPLETE"
	// ExecutorError means something had happen to worker node when running task
	ExecutorError State = "EXECUTOR_ERROR"
	// SystemError means something went wrong with the worker when running task
	SystemError State = "SYSTEM_ERROR"
	// Canceled means task was canceled
	Canceled State = "CANCELED"
)

// FileType can be file or directory
type FileType string

const (
	// File type of Input
	File FileType = "FILE"
	// Directory type of Input
	Directory FileType = "DIRECTORY"
)

// Input represents an input file to be used by task.
type Input struct {
	Name        string   `json:"name,omitempty"`
	Description string   `json:"description,omitempty"`
	URL         string   `json:"url"`
	Path        string   `json:"path"`
	Type        FileType `json:"type"`
	Content     string   `json:"content,omitempty"`
}

// Output represents a file generated by task
type Output struct {
	Name        string   `json:"name,omitempty"`
	Description string   `json:"description,omitempty"`
	URL         string   `json:"url"`
	Path        string   `json:"path"`
	Type        FileType `json:"type"`
}

// Resources represents computing requirements to run task
type Resources struct {
	CPUCores    int32    `json:"cpu_cores,omitempty"`
	RAMGb       float64  `json:"ram_gb,omitempty"`
	DiskGb      float64  `json:"disk_gb,omitempty"`
	Zones       []string `json:"zones,omitempty"`
	Preemptible bool     `json:"preemptible,omitempty"`
}

// Executor describes a command to be executed, and its environment.
type Executor struct {
	// Name of the container image
	Image string `json:"image"`
	// A sequence of program arguments to execute, where the first argument is the program to execute
	Command []string `json:"command"`
	// The working directory that the command will be executed in
	WorkDir string `json:"workdir,omitempty"`
	// Path inside the container to a file which will be piped to the executor's stdin
	Stdin string `json:"stdin,omitempty"`
	// Path inside the container to a file where the executor's stdout will be written to
	Stdout string `json:"stdout,omitempty"`
	// Path inside the container to a file where the executor's stderr will be written to
	Stderr string `json:"stderr,omitempty"`
	// Environment variables to set within the container
	Env map[string]string `json:"env,omitempty"`
}

// ExecutorLog represents processing times and logs of an executor
type ExecutorLog struct {
	StartTime time.Time `json:"start_time"` // Time the executor started
	EndTime   time.Time `json:"end_time"`   // Time the executor ended
	Stdout    string    `json:"stdout"`     // Stdout content
	Stderr    string    `json:"stderr"`     // Stderr content
	ExitCode  int32     `json:"exit_code"`  // Exit code
}

// OutputFileLog represents a log file
type OutputFileLog struct {
	URL       string `json:"url"`
	Path      string `json:"path"`
	SizeBytes string `json:"size_bytes"`
}

// Log represents processing times and logs of a task
type Log struct {
	// ExecutorLogs for each executor
	ExecutorLogs []*ExecutorLog `json:"logs,omitempty"`
	// Arbitrary logging metadata included by the implementation
	Metadata map[string]string `json:"metadata,omitempty"`
	// When the task started
	StartTime *time.Time `json:"start_time,omitempty"`
	// When the task ended
	EndTime *time.Time `json:"end_time,omitempty"`
	// Information about all output files
	Outputs []*OutputFileLog `json:"outputs,omitempty"`
	// System logs are any logs the system decides are relevant, which are not tied directly to an Executor process
	SystemLogs []string `json:"system_logs,omitempty"`
}

// Task is a collection of command to be executed to process data
type Task struct {
	ID           string            `json:"id" bson:"_id"`
	State        State             `json:"state"`
	Name         string            `json:"name,omitempty"`
	Description  string            `json:"description,omitempty"`
	Inputs       []*Input          `json:"inputs,omitempty"`
	Outputs      []*Output         `json:"outputs,omitempty"`
	Resources    *Resources        `json:"resources,omitempty"`
	Executors    []Executor        `json:"executors"`
	Volumes      []string          `json:"volumes,omitempty"`
	Tags         map[string]string `json:"tags,omitempty"`
	Logs         *Log              `json:"logs,omitempty"`
	CreationTime time.Time         `json:"creation_time"`

	// These fields extend TES API allowing client to know which node is processing the task.
	RemoteHost string `json:"remote_host"`
}

// ListTasksResponse represents a list of tasks previous submitted to system
type ListTasksResponse struct {
	Tasks         []*Task `json:"tasks"`
	NextPageToken string  `json:"next_page_token,omitempty"`
}

// CreateTaskResponse represents a task submitted and approved by the system
type CreateTaskResponse struct {
	ID string `json:"id"`
}

// CancelTaskResponse represents that a task was canceled
type CancelTaskResponse struct {
}

// View defines which task field should be returned
type View string

const (
	// Minimal returns only task ID and state
	Minimal View = "MINIMAL"
	// Basic returns all fields except
	// - Task.ExecutorLog.Stdout
	// - Task.ExecutorLog.Stderr
	// - Input.Content
	// - TaskLog.SystemLogs
	Basic View = "BASIC"
	// Full returns all fields
	Full View = "FULL"
)

// Active returns true if task state is
// - Queued
// - Initializing
// - Running
// - Paused
func (t *Task) Active() bool {
	return t.State == Queued || t.State == Initializing || t.State == Running || t.State == Paused
}

func (t *Task) String() string {
	var host string
	if t.RemoteHost != "" {
		host = " at " + t.RemoteHost
	}
	return fmt.Sprintf("task %s CPU=%d RAM=%.2f %s%s", t.ID, t.Resources.CPUCores, t.Resources.RAMGb, t.State, host)
}

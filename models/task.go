package models

import (
	"fmt"
	"time"
)

// State of a task
type State string

const (
	// Unknown means task state is not defined
	Unknown State = "UNKNOWN"
	// Queued means task was submitted and waiting
	Queued State = "QUEUED"
	// Initializing means required files are be gathering before execution
	// for example, downloading Docker image
	Initializing State = "INITIALIZING"
	// Running means tasks is been executed by some worker node
	Running State = "RUNNING"
	// Paused is not used
	Paused State = "PAUSED"
	// Complete means task was terminated successfully, aka 0 return code
	Complete State = "COMPLETE"
	// ExecutorError means something had happen to worker node when running task
	ExecutorError State = "EXECUTOR_ERROR"
	// SystemError means something went wrong with the worker when running task
	SystemError State = "SYSTEM_ERROR"
	// Canceled means task was canceled
	Canceled State = "CANCELED"
)

// ActiveStates returns task states considered active.
func ActiveStates() []State {
	return []State{Queued, Initializing, Running, Paused}
}

// ErrorStates returns task states considered failed.
func ErrorStates() []State {
	return []State{ExecutorError, SystemError}
}

// TerminatedStates returns task states considered completed.
func TerminatedStates() []State {
	return []State{Complete, ExecutorError, SystemError, Canceled}
}

// FileType can be file or directory
type FileType string

const (
	// File type of Input
	File FileType = "FILE"
	// Directory type of Input
	Directory FileType = "DIRECTORY"
)

// Input represents an input file to be used by task.
type Input struct {
	Name        string   `json:"name,omitempty"`
	Description string   `json:"description,omitempty"`
	URL         string   `json:"url"`
	Path        string   `json:"path"`
	Type        FileType `json:"type"`
	Content     string   `json:"content,omitempty"`
}

// Output represents a file generated by task
type Output struct {
	Name        string   `json:"name,omitempty"`
	Description string   `json:"description,omitempty"`
	URL         string   `json:"url"`
	Path        string   `json:"path"`
	Type        FileType `json:"type"`
}

// Resources represents computing requirements to run task
type Resources struct {
	CPUCores    int32    `json:"cpu_cores,omitempty"`
	RAMGb       float64  `json:"ram_gb,omitempty"`
	DiskGb      float64  `json:"disk_gb,omitempty"`
	Zones       []string `json:"zones,omitempty"`
	Preemptible bool     `json:"preemptible,omitempty"`
}

// Executor describes a command to be executed, and its environment.
type Executor struct {
	// Name of the container image
	Image string `json:"image"`
	// A sequence of program arguments to execute, where the first argument is the program to execute
	Command []string `json:"command"`
	// The working directory that the command will be executed in
	WorkDir string `json:"workdir,omitempty"`
	// Path inside the container to a file which will be piped to the executor's stdin
	Stdin string `json:"stdin,omitempty"`
	// Path inside the container to a file where the executor's stdout will be written to
	Stdout string `json:"stdout,omitempty"`
	// Path inside the container to a file where the executor's stderr will be written to
	Stderr string `json:"stderr,omitempty"`
	// Environment variables to set within the container
	Env map[string]string `json:"env,omitempty"`
}

// ExecutorLog represents processing times and logs of an executor
type ExecutorLog struct {
	StartTime time.Time `json:"start_time"` // Time the executor started
	EndTime   time.Time `json:"end_time"`   // Time the executor ended
	Stdout    string    `json:"stdout"`     // Stdout content
	Stderr    string    `json:"stderr"`     // Stderr content
	ExitCode  int32     `json:"exit_code"`  // Exit code
}

// OutputFileLog represents a log file
type OutputFileLog struct {
	URL       string `json:"url"`
	Path      string `json:"path"`
	SizeBytes string `json:"size_bytes"`
}

// Log represents processing times and logs of a task
type Log struct {
	// ExecutorLogs for each executor
	ExecutorLogs []*ExecutorLog `json:"logs,omitempty"`
	// Arbitrary logging metadata included by the implementation
	Metadata map[string]string `json:"metadata,omitempty"`
	// When the task started
	StartTime *time.Time `json:"start_time,omitempty"`
	// When the task ended
	EndTime *time.Time `json:"end_time,omitempty"`
	// Information about all output files
	Outputs []*OutputFileLog `json:"outputs,omitempty"`
	// System logs are any logs the system decides are relevant, which are not tied directly to an Executor process
	SystemLogs []string `json:"system_logs,omitempty"`
}

// Worker represents a active computing node.
type Worker struct {
	// Hostname of computing node.
	Host string `json:"host,omitempty"`
	// Total CPU time in nanoseconds across all cores.
	CPUTime uint64 `json:"cpu_time"`
	// Maximum CPU percentage ever recorded.
	CPUPercentage float64 `json:"cpu_percentage"`
	// Maximum memory used ever recorded in bytes.
	Memory uint64 `json:"memory"`
}

// Task is a collection of command to be executed to process data
type Task struct {
	ID          string            `json:"id" bson:"_id"`
	Name        string            `json:"name,omitempty"`
	Description string            `json:"description,omitempty"`
	Created     *time.Time        `json:"creation_time,omitempty"`
	State       State             `json:"state"`
	Resources   *Resources        `json:"resources,omitempty"`
	Executors   []Executor        `json:"executors,omitempty"`
	Inputs      []*Input          `json:"inputs,omitempty"`
	Outputs     []*Output         `json:"outputs,omitempty"`
	Volumes     []string          `json:"volumes,omitempty"`
	Tags        map[string]string `json:"tags,omitempty"`
	Logs        *Log              `json:"logs,omitempty"`

	// RNNR specific fields.
	Worker  *Worker   `json:"worker,omitempty"`
	Updated time.Time `json:"updated"`
}

// ListTasksResponse represents a list of tasks previous submitted to system
type ListTasksResponse struct {
	Tasks         []*Task `json:"tasks"`
	NextPageToken string  `json:"next_page_token,omitempty"`
}

// CreateTaskResponse represents a task submitted and approved by the system
type CreateTaskResponse struct {
	ID string `json:"id"`
}

// CancelTaskResponse represents that a task was canceled
type CancelTaskResponse struct {
}

// View defines which task field should be returned
type View string

const (
	// Minimal returns only task ID and state
	Minimal View = "MINIMAL"
	// Basic returns all fields except
	// - Logs.ExecutorLogs.Stdout
	// - Logs.ExecutorLogs.Stderr
	// - Inputs.Content
	// - Logs.SystemLogs
	Basic View = "BASIC"
	// Full returns all fields
	Full View = "FULL"
)

// Active returns true if task is active (queued, initializing, running and paused).
func (t *Task) Active() bool {
	return t.State == Queued || t.State == Initializing || t.State == Running || t.State == Paused
}

// Failed returns true if task failed (executor error and system error).
func (t *Task) Failed() bool {
	return t.State == ExecutorError || t.State == SystemError
}

// Terminated returns true if task is completed (complete, executor error, system error and canceled).
func (t *Task) Terminated() bool {
	return t.State == Complete || t.State == ExecutorError || t.State == SystemError || t.State == Canceled
}

func (t *Task) String() string {
	var host string
	if t.Worker != nil {
		host = " at " + t.Worker.Host
	}
	return fmt.Sprintf("task %s CPU=%d RAM=%.2f %s%s", t.ID, t.Resources.CPUCores, t.Resources.RAMGb, t.State, host)
}

// Elapsed computes elapsed time of task execution.
func (t *Task) Elapsed() time.Duration {
	if t.State == Complete {
		return t.Logs.EndTime.Sub(*t.Logs.StartTime)
	}

	if t.State == Running {
		return time.Since(*t.Logs.StartTime)
	}

	return time.Duration(0)
}
